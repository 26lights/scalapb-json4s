// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package test.test



@SerialVersionUID(0L)
final case class MyTest(
    hello: scala.Option[String] = None,
    foobar: scala.Option[Int] = None,
    bazinga: scala.Option[Long] = None,
    primitiveSequence: scala.collection.Seq[String] = Nil,
    repMessage: scala.collection.Seq[test.test.MyTest] = Nil,
    optMessage: scala.Option[test.test.MyTest] = None,
    stringToInt32: scala.collection.immutable.Map[String, Int] = scala.collection.immutable.Map.empty,
    intToMytest: scala.collection.immutable.Map[Int, test.test.MyTest] = scala.collection.immutable.Map.empty,
    repEnum: scala.collection.Seq[test.test.MyEnum] = Nil,
    optEnum: scala.Option[test.test.MyEnum] = None,
    intToEnum: scala.collection.immutable.Map[Int, test.test.MyEnum] = scala.collection.immutable.Map.empty,
    boolToString: scala.collection.immutable.Map[Boolean, String] = scala.collection.immutable.Map.empty,
    stringToBool: scala.collection.immutable.Map[String, Boolean] = scala.collection.immutable.Map.empty
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[MyTest] with com.trueaccord.lenses.Updatable[MyTest] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      if (hello.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeStringSize(1, hello.get) }
      if (foobar.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, foobar.get) }
      if (bazinga.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeInt64Size(3, bazinga.get) }
      primitiveSequence.foreach(primitiveSequence => __size += com.google.protobuf.CodedOutputStream.computeStringSize(4, primitiveSequence))
      repMessage.foreach(repMessage => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(repMessage.serializedSize) + repMessage.serializedSize)
      if (optMessage.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(optMessage.get.serializedSize) + optMessage.get.serializedSize }
      stringToInt32.foreach(stringToInt32 => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(test.test.MyTest._typemapper_stringToInt32.toBase(stringToInt32).serializedSize) + test.test.MyTest._typemapper_stringToInt32.toBase(stringToInt32).serializedSize)
      intToMytest.foreach(intToMytest => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(test.test.MyTest._typemapper_intToMytest.toBase(intToMytest).serializedSize) + test.test.MyTest._typemapper_intToMytest.toBase(intToMytest).serializedSize)
      repEnum.foreach(repEnum => __size += com.google.protobuf.CodedOutputStream.computeEnumSize(9, repEnum.value))
      if (optEnum.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeEnumSize(10, optEnum.get.value) }
      intToEnum.foreach(intToEnum => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(test.test.MyTest._typemapper_intToEnum.toBase(intToEnum).serializedSize) + test.test.MyTest._typemapper_intToEnum.toBase(intToEnum).serializedSize)
      boolToString.foreach(boolToString => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(test.test.MyTest._typemapper_boolToString.toBase(boolToString).serializedSize) + test.test.MyTest._typemapper_boolToString.toBase(boolToString).serializedSize)
      stringToBool.foreach(stringToBool => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(test.test.MyTest._typemapper_stringToBool.toBase(stringToBool).serializedSize) + test.test.MyTest._typemapper_stringToBool.toBase(stringToBool).serializedSize)
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: com.google.protobuf.CodedOutputStream): Unit = {
      hello.foreach { __v =>
        _output__.writeString(1, __v)
      };
      foobar.foreach { __v =>
        _output__.writeInt32(2, __v)
      };
      bazinga.foreach { __v =>
        _output__.writeInt64(3, __v)
      };
      primitiveSequence.foreach { __v =>
        _output__.writeString(4, __v)
      };
      repMessage.foreach { __v =>
        _output__.writeTag(5, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      optMessage.foreach { __v =>
        _output__.writeTag(6, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      stringToInt32.foreach { __v =>
        _output__.writeTag(7, 2)
        _output__.writeUInt32NoTag(test.test.MyTest._typemapper_stringToInt32.toBase(__v).serializedSize)
        test.test.MyTest._typemapper_stringToInt32.toBase(__v).writeTo(_output__)
      };
      intToMytest.foreach { __v =>
        _output__.writeTag(8, 2)
        _output__.writeUInt32NoTag(test.test.MyTest._typemapper_intToMytest.toBase(__v).serializedSize)
        test.test.MyTest._typemapper_intToMytest.toBase(__v).writeTo(_output__)
      };
      repEnum.foreach { __v =>
        _output__.writeEnum(9, __v.value)
      };
      optEnum.foreach { __v =>
        _output__.writeEnum(10, __v.value)
      };
      intToEnum.foreach { __v =>
        _output__.writeTag(11, 2)
        _output__.writeUInt32NoTag(test.test.MyTest._typemapper_intToEnum.toBase(__v).serializedSize)
        test.test.MyTest._typemapper_intToEnum.toBase(__v).writeTo(_output__)
      };
      boolToString.foreach { __v =>
        _output__.writeTag(12, 2)
        _output__.writeUInt32NoTag(test.test.MyTest._typemapper_boolToString.toBase(__v).serializedSize)
        test.test.MyTest._typemapper_boolToString.toBase(__v).writeTo(_output__)
      };
      stringToBool.foreach { __v =>
        _output__.writeTag(13, 2)
        _output__.writeUInt32NoTag(test.test.MyTest._typemapper_stringToBool.toBase(__v).serializedSize)
        test.test.MyTest._typemapper_stringToBool.toBase(__v).writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: com.google.protobuf.CodedInputStream): test.test.MyTest = {
      var __hello = this.hello
      var __foobar = this.foobar
      var __bazinga = this.bazinga
      val __primitiveSequence = (scala.collection.immutable.Vector.newBuilder[String] ++= this.primitiveSequence)
      val __repMessage = (scala.collection.immutable.Vector.newBuilder[test.test.MyTest] ++= this.repMessage)
      var __optMessage = this.optMessage
      val __stringToInt32 = (scala.collection.immutable.Map.newBuilder[String, Int] ++= this.stringToInt32)
      val __intToMytest = (scala.collection.immutable.Map.newBuilder[Int, test.test.MyTest] ++= this.intToMytest)
      val __repEnum = (scala.collection.immutable.Vector.newBuilder[test.test.MyEnum] ++= this.repEnum)
      var __optEnum = this.optEnum
      val __intToEnum = (scala.collection.immutable.Map.newBuilder[Int, test.test.MyEnum] ++= this.intToEnum)
      val __boolToString = (scala.collection.immutable.Map.newBuilder[Boolean, String] ++= this.boolToString)
      val __stringToBool = (scala.collection.immutable.Map.newBuilder[String, Boolean] ++= this.stringToBool)
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __hello = Some(_input__.readString())
          case 16 =>
            __foobar = Some(_input__.readInt32())
          case 24 =>
            __bazinga = Some(_input__.readInt64())
          case 34 =>
            __primitiveSequence += _input__.readString()
          case 42 =>
            __repMessage += com.trueaccord.scalapb.LiteParser.readMessage(_input__, test.test.MyTest.defaultInstance)
          case 50 =>
            __optMessage = Some(com.trueaccord.scalapb.LiteParser.readMessage(_input__, __optMessage.getOrElse(test.test.MyTest.defaultInstance)))
          case 58 =>
            __stringToInt32 += test.test.MyTest._typemapper_stringToInt32.toCustom(com.trueaccord.scalapb.LiteParser.readMessage(_input__, test.test.MyTest.StringToInt32Entry.defaultInstance))
          case 66 =>
            __intToMytest += test.test.MyTest._typemapper_intToMytest.toCustom(com.trueaccord.scalapb.LiteParser.readMessage(_input__, test.test.MyTest.IntToMytestEntry.defaultInstance))
          case 72 =>
            __repEnum += test.test.MyEnum.fromValue(_input__.readEnum())
          case 74 => {
            val length = _input__.readRawVarint32()
            val oldLimit = _input__.pushLimit(length)
            while (_input__.getBytesUntilLimit > 0) {
              __repEnum += test.test.MyEnum.fromValue(_input__.readEnum)
            }
            _input__.popLimit(oldLimit)
          }
          case 80 =>
            __optEnum = Some(test.test.MyEnum.fromValue(_input__.readEnum()))
          case 90 =>
            __intToEnum += test.test.MyTest._typemapper_intToEnum.toCustom(com.trueaccord.scalapb.LiteParser.readMessage(_input__, test.test.MyTest.IntToEnumEntry.defaultInstance))
          case 98 =>
            __boolToString += test.test.MyTest._typemapper_boolToString.toCustom(com.trueaccord.scalapb.LiteParser.readMessage(_input__, test.test.MyTest.BoolToStringEntry.defaultInstance))
          case 106 =>
            __stringToBool += test.test.MyTest._typemapper_stringToBool.toCustom(com.trueaccord.scalapb.LiteParser.readMessage(_input__, test.test.MyTest.StringToBoolEntry.defaultInstance))
          case tag => _input__.skipField(tag)
        }
      }
      test.test.MyTest(
          hello = __hello,
          foobar = __foobar,
          bazinga = __bazinga,
          primitiveSequence = __primitiveSequence.result(),
          repMessage = __repMessage.result(),
          optMessage = __optMessage,
          stringToInt32 = __stringToInt32.result(),
          intToMytest = __intToMytest.result(),
          repEnum = __repEnum.result(),
          optEnum = __optEnum,
          intToEnum = __intToEnum.result(),
          boolToString = __boolToString.result(),
          stringToBool = __stringToBool.result()
      )
    }
    def getHello: String = hello.getOrElse("")
    def clearHello: MyTest = copy(hello = None)
    def withHello(__v: String): MyTest = copy(hello = Some(__v))
    def getFoobar: Int = foobar.getOrElse(0)
    def clearFoobar: MyTest = copy(foobar = None)
    def withFoobar(__v: Int): MyTest = copy(foobar = Some(__v))
    def getBazinga: Long = bazinga.getOrElse(0L)
    def clearBazinga: MyTest = copy(bazinga = None)
    def withBazinga(__v: Long): MyTest = copy(bazinga = Some(__v))
    def clearPrimitiveSequence = copy(primitiveSequence = scala.collection.Seq.empty)
    def addPrimitiveSequence(__vs: String*): MyTest = addAllPrimitiveSequence(__vs)
    def addAllPrimitiveSequence(__vs: TraversableOnce[String]): MyTest = copy(primitiveSequence = primitiveSequence ++ __vs)
    def withPrimitiveSequence(__v: scala.collection.Seq[String]): MyTest = copy(primitiveSequence = __v)
    def clearRepMessage = copy(repMessage = scala.collection.Seq.empty)
    def addRepMessage(__vs: test.test.MyTest*): MyTest = addAllRepMessage(__vs)
    def addAllRepMessage(__vs: TraversableOnce[test.test.MyTest]): MyTest = copy(repMessage = repMessage ++ __vs)
    def withRepMessage(__v: scala.collection.Seq[test.test.MyTest]): MyTest = copy(repMessage = __v)
    def getOptMessage: test.test.MyTest = optMessage.getOrElse(test.test.MyTest.defaultInstance)
    def clearOptMessage: MyTest = copy(optMessage = None)
    def withOptMessage(__v: test.test.MyTest): MyTest = copy(optMessage = Some(__v))
    def clearStringToInt32 = copy(stringToInt32 = scala.collection.immutable.Map.empty)
    def addStringToInt32(__vs: (String, Int)*): MyTest = addAllStringToInt32(__vs)
    def addAllStringToInt32(__vs: TraversableOnce[(String, Int)]): MyTest = copy(stringToInt32 = stringToInt32 ++ __vs)
    def withStringToInt32(__v: scala.collection.immutable.Map[String, Int]): MyTest = copy(stringToInt32 = __v)
    def clearIntToMytest = copy(intToMytest = scala.collection.immutable.Map.empty)
    def addIntToMytest(__vs: (Int, test.test.MyTest)*): MyTest = addAllIntToMytest(__vs)
    def addAllIntToMytest(__vs: TraversableOnce[(Int, test.test.MyTest)]): MyTest = copy(intToMytest = intToMytest ++ __vs)
    def withIntToMytest(__v: scala.collection.immutable.Map[Int, test.test.MyTest]): MyTest = copy(intToMytest = __v)
    def clearRepEnum = copy(repEnum = scala.collection.Seq.empty)
    def addRepEnum(__vs: test.test.MyEnum*): MyTest = addAllRepEnum(__vs)
    def addAllRepEnum(__vs: TraversableOnce[test.test.MyEnum]): MyTest = copy(repEnum = repEnum ++ __vs)
    def withRepEnum(__v: scala.collection.Seq[test.test.MyEnum]): MyTest = copy(repEnum = __v)
    def getOptEnum: test.test.MyEnum = optEnum.getOrElse(test.test.MyEnum.UNKNOWN)
    def clearOptEnum: MyTest = copy(optEnum = None)
    def withOptEnum(__v: test.test.MyEnum): MyTest = copy(optEnum = Some(__v))
    def clearIntToEnum = copy(intToEnum = scala.collection.immutable.Map.empty)
    def addIntToEnum(__vs: (Int, test.test.MyEnum)*): MyTest = addAllIntToEnum(__vs)
    def addAllIntToEnum(__vs: TraversableOnce[(Int, test.test.MyEnum)]): MyTest = copy(intToEnum = intToEnum ++ __vs)
    def withIntToEnum(__v: scala.collection.immutable.Map[Int, test.test.MyEnum]): MyTest = copy(intToEnum = __v)
    def clearBoolToString = copy(boolToString = scala.collection.immutable.Map.empty)
    def addBoolToString(__vs: (Boolean, String)*): MyTest = addAllBoolToString(__vs)
    def addAllBoolToString(__vs: TraversableOnce[(Boolean, String)]): MyTest = copy(boolToString = boolToString ++ __vs)
    def withBoolToString(__v: scala.collection.immutable.Map[Boolean, String]): MyTest = copy(boolToString = __v)
    def clearStringToBool = copy(stringToBool = scala.collection.immutable.Map.empty)
    def addStringToBool(__vs: (String, Boolean)*): MyTest = addAllStringToBool(__vs)
    def addAllStringToBool(__vs: TraversableOnce[(String, Boolean)]): MyTest = copy(stringToBool = stringToBool ++ __vs)
    def withStringToBool(__v: scala.collection.immutable.Map[String, Boolean]): MyTest = copy(stringToBool = __v)
    def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
      __field.getNumber match {
        case 1 => hello.getOrElse(null)
        case 2 => foobar.getOrElse(null)
        case 3 => bazinga.getOrElse(null)
        case 4 => primitiveSequence
        case 5 => repMessage
        case 6 => optMessage.getOrElse(null)
        case 7 => stringToInt32.map(test.test.MyTest._typemapper_stringToInt32.toBase(_))
        case 8 => intToMytest.map(test.test.MyTest._typemapper_intToMytest.toBase(_))
        case 9 => repEnum.map(_.valueDescriptor)
        case 10 => optEnum.map(_.valueDescriptor).getOrElse(null)
        case 11 => intToEnum.map(test.test.MyTest._typemapper_intToEnum.toBase(_))
        case 12 => boolToString.map(test.test.MyTest._typemapper_boolToString.toBase(_))
        case 13 => stringToBool.map(test.test.MyTest._typemapper_stringToBool.toBase(_))
      }
    }
    override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = test.test.MyTest
}

object MyTest extends com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): test.test.MyTest = {
    require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
    val __fields = descriptor.getFields
    test.test.MyTest(
      __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[String]],
      __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[Int]],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[Long]],
      __fieldsMap.getOrElse(__fields.get(3), Nil).asInstanceOf[scala.collection.Seq[String]],
      __fieldsMap.getOrElse(__fields.get(4), Nil).asInstanceOf[scala.collection.Seq[test.test.MyTest]],
      __fieldsMap.get(__fields.get(5)).asInstanceOf[scala.Option[test.test.MyTest]],
      __fieldsMap.getOrElse(__fields.get(6), Nil).asInstanceOf[scala.collection.Seq[test.test.MyTest.StringToInt32Entry]].map(test.test.MyTest._typemapper_stringToInt32.toCustom(_))(scala.collection.breakOut),
      __fieldsMap.getOrElse(__fields.get(7), Nil).asInstanceOf[scala.collection.Seq[test.test.MyTest.IntToMytestEntry]].map(test.test.MyTest._typemapper_intToMytest.toCustom(_))(scala.collection.breakOut),
      __fieldsMap.getOrElse(__fields.get(8), Nil).asInstanceOf[scala.collection.Seq[com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => test.test.MyEnum.fromValue(__e.getNumber)),
      __fieldsMap.get(__fields.get(9)).asInstanceOf[scala.Option[com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => test.test.MyEnum.fromValue(__e.getNumber)),
      __fieldsMap.getOrElse(__fields.get(10), Nil).asInstanceOf[scala.collection.Seq[test.test.MyTest.IntToEnumEntry]].map(test.test.MyTest._typemapper_intToEnum.toCustom(_))(scala.collection.breakOut),
      __fieldsMap.getOrElse(__fields.get(11), Nil).asInstanceOf[scala.collection.Seq[test.test.MyTest.BoolToStringEntry]].map(test.test.MyTest._typemapper_boolToString.toCustom(_))(scala.collection.breakOut),
      __fieldsMap.getOrElse(__fields.get(12), Nil).asInstanceOf[scala.collection.Seq[test.test.MyTest.StringToBoolEntry]].map(test.test.MyTest._typemapper_stringToBool.toCustom(_))(scala.collection.breakOut)
    )
  }
  def descriptor: com.google.protobuf.Descriptors.Descriptor = TestProto.descriptor.getMessageTypes.get(0)
  def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    require(__field.getContainingType() == descriptor, "FieldDescriptor does not match message type.")
    var __out: com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    __field.getNumber match {
      case 5 => __out = test.test.MyTest
      case 6 => __out = test.test.MyTest
      case 7 => __out = test.test.MyTest.StringToInt32Entry
      case 8 => __out = test.test.MyTest.IntToMytestEntry
      case 11 => __out = test.test.MyTest.IntToEnumEntry
      case 12 => __out = test.test.MyTest.BoolToStringEntry
      case 13 => __out = test.test.MyTest.StringToBoolEntry
    }
  __out
  }
  def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
    require(__field.getContainingType() == descriptor, "FieldDescriptor does not match message type.")
    __field.getNumber match {
      case 9 => test.test.MyEnum
      case 10 => test.test.MyEnum
    }
  }
  lazy val defaultInstance = test.test.MyTest(
  )
  @SerialVersionUID(0L)
  final case class StringToInt32Entry(
      key: scala.Option[String] = None,
      value: scala.Option[Int] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[StringToInt32Entry] with com.trueaccord.lenses.Updatable[StringToInt32Entry] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        if (key.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeStringSize(1, key.get) }
        if (value.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(2, value.get) }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: com.google.protobuf.CodedOutputStream): Unit = {
        key.foreach { __v =>
          _output__.writeString(1, __v)
        };
        value.foreach { __v =>
          _output__.writeInt32(2, __v)
        };
      }
      def mergeFrom(`_input__`: com.google.protobuf.CodedInputStream): test.test.MyTest.StringToInt32Entry = {
        var __key = this.key
        var __value = this.value
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __key = Some(_input__.readString())
            case 16 =>
              __value = Some(_input__.readInt32())
            case tag => _input__.skipField(tag)
          }
        }
        test.test.MyTest.StringToInt32Entry(
            key = __key,
            value = __value
        )
      }
      def getKey: String = key.getOrElse("")
      def clearKey: StringToInt32Entry = copy(key = None)
      def withKey(__v: String): StringToInt32Entry = copy(key = Some(__v))
      def getValue: Int = value.getOrElse(0)
      def clearValue: StringToInt32Entry = copy(value = None)
      def withValue(__v: Int): StringToInt32Entry = copy(value = Some(__v))
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => key.getOrElse(null)
          case 2 => value.getOrElse(null)
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = test.test.MyTest.StringToInt32Entry
  }
  
  object StringToInt32Entry extends com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.StringToInt32Entry] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.StringToInt32Entry] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): test.test.MyTest.StringToInt32Entry = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      test.test.MyTest.StringToInt32Entry(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[String]],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[Int]]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = test.test.MyTest.descriptor.getNestedTypes.get(0)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = test.test.MyTest.StringToInt32Entry(
    )
    implicit class StringToInt32EntryLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest.StringToInt32Entry]) extends com.trueaccord.lenses.ObjectLens[UpperPB, test.test.MyTest.StringToInt32Entry](_l) {
      def key: com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getKey)((c_, f_) => c_.copy(key = Some(f_)))
      def optionalKey: com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.getValue)((c_, f_) => c_.copy(value = Some(f_)))
      def optionalValue: com.trueaccord.lenses.Lens[UpperPB, scala.Option[Int]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    implicit val keyValueMapper: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToInt32Entry, (String, Int)] =
      com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToInt32Entry, (String, Int)](__m => (__m.getKey, __m.getValue))(__p => test.test.MyTest.StringToInt32Entry(Some(__p._1), Some(__p._2)))
  }
  
  @SerialVersionUID(0L)
  final case class IntToMytestEntry(
      key: scala.Option[Int] = None,
      value: scala.Option[test.test.MyTest] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[IntToMytestEntry] with com.trueaccord.lenses.Updatable[IntToMytestEntry] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        if (key.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, key.get) }
        if (value.isDefined) { __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(value.get.serializedSize) + value.get.serializedSize }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: com.google.protobuf.CodedOutputStream): Unit = {
        key.foreach { __v =>
          _output__.writeInt32(1, __v)
        };
        value.foreach { __v =>
          _output__.writeTag(2, 2)
          _output__.writeUInt32NoTag(__v.serializedSize)
          __v.writeTo(_output__)
        };
      }
      def mergeFrom(`_input__`: com.google.protobuf.CodedInputStream): test.test.MyTest.IntToMytestEntry = {
        var __key = this.key
        var __value = this.value
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __key = Some(_input__.readInt32())
            case 18 =>
              __value = Some(com.trueaccord.scalapb.LiteParser.readMessage(_input__, __value.getOrElse(test.test.MyTest.defaultInstance)))
            case tag => _input__.skipField(tag)
          }
        }
        test.test.MyTest.IntToMytestEntry(
            key = __key,
            value = __value
        )
      }
      def getKey: Int = key.getOrElse(0)
      def clearKey: IntToMytestEntry = copy(key = None)
      def withKey(__v: Int): IntToMytestEntry = copy(key = Some(__v))
      def getValue: test.test.MyTest = value.getOrElse(test.test.MyTest.defaultInstance)
      def clearValue: IntToMytestEntry = copy(value = None)
      def withValue(__v: test.test.MyTest): IntToMytestEntry = copy(value = Some(__v))
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => key.getOrElse(null)
          case 2 => value.getOrElse(null)
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = test.test.MyTest.IntToMytestEntry
  }
  
  object IntToMytestEntry extends com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.IntToMytestEntry] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.IntToMytestEntry] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): test.test.MyTest.IntToMytestEntry = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      test.test.MyTest.IntToMytestEntry(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[Int]],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[test.test.MyTest]]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = test.test.MyTest.descriptor.getNestedTypes.get(1)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
      require(__field.getContainingType() == descriptor, "FieldDescriptor does not match message type.")
      var __out: com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
      __field.getNumber match {
        case 2 => __out = test.test.MyTest
      }
    __out
    }
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = test.test.MyTest.IntToMytestEntry(
    )
    implicit class IntToMytestEntryLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest.IntToMytestEntry]) extends com.trueaccord.lenses.ObjectLens[UpperPB, test.test.MyTest.IntToMytestEntry](_l) {
      def key: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.getKey)((c_, f_) => c_.copy(key = Some(f_)))
      def optionalKey: com.trueaccord.lenses.Lens[UpperPB, scala.Option[Int]] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest] = field(_.getValue)((c_, f_) => c_.copy(value = Some(f_)))
      def optionalValue: com.trueaccord.lenses.Lens[UpperPB, scala.Option[test.test.MyTest]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    implicit val keyValueMapper: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToMytestEntry, (Int, test.test.MyTest)] =
      com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToMytestEntry, (Int, test.test.MyTest)](__m => (__m.getKey, __m.getValue))(__p => test.test.MyTest.IntToMytestEntry(Some(__p._1), Some(__p._2)))
  }
  
  @SerialVersionUID(0L)
  final case class IntToEnumEntry(
      key: scala.Option[Int] = None,
      value: scala.Option[test.test.MyEnum] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[IntToEnumEntry] with com.trueaccord.lenses.Updatable[IntToEnumEntry] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        if (key.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, key.get) }
        if (value.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeEnumSize(2, value.get.value) }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: com.google.protobuf.CodedOutputStream): Unit = {
        key.foreach { __v =>
          _output__.writeInt32(1, __v)
        };
        value.foreach { __v =>
          _output__.writeEnum(2, __v.value)
        };
      }
      def mergeFrom(`_input__`: com.google.protobuf.CodedInputStream): test.test.MyTest.IntToEnumEntry = {
        var __key = this.key
        var __value = this.value
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __key = Some(_input__.readInt32())
            case 16 =>
              __value = Some(test.test.MyEnum.fromValue(_input__.readEnum()))
            case tag => _input__.skipField(tag)
          }
        }
        test.test.MyTest.IntToEnumEntry(
            key = __key,
            value = __value
        )
      }
      def getKey: Int = key.getOrElse(0)
      def clearKey: IntToEnumEntry = copy(key = None)
      def withKey(__v: Int): IntToEnumEntry = copy(key = Some(__v))
      def getValue: test.test.MyEnum = value.getOrElse(test.test.MyEnum.UNKNOWN)
      def clearValue: IntToEnumEntry = copy(value = None)
      def withValue(__v: test.test.MyEnum): IntToEnumEntry = copy(value = Some(__v))
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => key.getOrElse(null)
          case 2 => value.map(_.valueDescriptor).getOrElse(null)
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = test.test.MyTest.IntToEnumEntry
  }
  
  object IntToEnumEntry extends com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.IntToEnumEntry] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.IntToEnumEntry] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): test.test.MyTest.IntToEnumEntry = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      test.test.MyTest.IntToEnumEntry(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[Int]],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[com.google.protobuf.Descriptors.EnumValueDescriptor]].map(__e => test.test.MyEnum.fromValue(__e.getNumber))
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = test.test.MyTest.descriptor.getNestedTypes.get(2)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = {
      require(__field.getContainingType() == descriptor, "FieldDescriptor does not match message type.")
      __field.getNumber match {
        case 2 => test.test.MyEnum
      }
    }
    lazy val defaultInstance = test.test.MyTest.IntToEnumEntry(
    )
    implicit class IntToEnumEntryLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest.IntToEnumEntry]) extends com.trueaccord.lenses.ObjectLens[UpperPB, test.test.MyTest.IntToEnumEntry](_l) {
      def key: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.getKey)((c_, f_) => c_.copy(key = Some(f_)))
      def optionalKey: com.trueaccord.lenses.Lens[UpperPB, scala.Option[Int]] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: com.trueaccord.lenses.Lens[UpperPB, test.test.MyEnum] = field(_.getValue)((c_, f_) => c_.copy(value = Some(f_)))
      def optionalValue: com.trueaccord.lenses.Lens[UpperPB, scala.Option[test.test.MyEnum]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    implicit val keyValueMapper: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToEnumEntry, (Int, test.test.MyEnum)] =
      com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToEnumEntry, (Int, test.test.MyEnum)](__m => (__m.getKey, __m.getValue))(__p => test.test.MyTest.IntToEnumEntry(Some(__p._1), Some(__p._2)))
  }
  
  @SerialVersionUID(0L)
  final case class BoolToStringEntry(
      key: scala.Option[Boolean] = None,
      value: scala.Option[String] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[BoolToStringEntry] with com.trueaccord.lenses.Updatable[BoolToStringEntry] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        if (key.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeBoolSize(1, key.get) }
        if (value.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeStringSize(2, value.get) }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: com.google.protobuf.CodedOutputStream): Unit = {
        key.foreach { __v =>
          _output__.writeBool(1, __v)
        };
        value.foreach { __v =>
          _output__.writeString(2, __v)
        };
      }
      def mergeFrom(`_input__`: com.google.protobuf.CodedInputStream): test.test.MyTest.BoolToStringEntry = {
        var __key = this.key
        var __value = this.value
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 8 =>
              __key = Some(_input__.readBool())
            case 18 =>
              __value = Some(_input__.readString())
            case tag => _input__.skipField(tag)
          }
        }
        test.test.MyTest.BoolToStringEntry(
            key = __key,
            value = __value
        )
      }
      def getKey: Boolean = key.getOrElse(false)
      def clearKey: BoolToStringEntry = copy(key = None)
      def withKey(__v: Boolean): BoolToStringEntry = copy(key = Some(__v))
      def getValue: String = value.getOrElse("")
      def clearValue: BoolToStringEntry = copy(value = None)
      def withValue(__v: String): BoolToStringEntry = copy(value = Some(__v))
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => key.getOrElse(null)
          case 2 => value.getOrElse(null)
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = test.test.MyTest.BoolToStringEntry
  }
  
  object BoolToStringEntry extends com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.BoolToStringEntry] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.BoolToStringEntry] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): test.test.MyTest.BoolToStringEntry = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      test.test.MyTest.BoolToStringEntry(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[Boolean]],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[String]]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = test.test.MyTest.descriptor.getNestedTypes.get(3)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = test.test.MyTest.BoolToStringEntry(
    )
    implicit class BoolToStringEntryLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest.BoolToStringEntry]) extends com.trueaccord.lenses.ObjectLens[UpperPB, test.test.MyTest.BoolToStringEntry](_l) {
      def key: com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.getKey)((c_, f_) => c_.copy(key = Some(f_)))
      def optionalKey: com.trueaccord.lenses.Lens[UpperPB, scala.Option[Boolean]] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getValue)((c_, f_) => c_.copy(value = Some(f_)))
      def optionalValue: com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    implicit val keyValueMapper: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.BoolToStringEntry, (Boolean, String)] =
      com.trueaccord.scalapb.TypeMapper[test.test.MyTest.BoolToStringEntry, (Boolean, String)](__m => (__m.getKey, __m.getValue))(__p => test.test.MyTest.BoolToStringEntry(Some(__p._1), Some(__p._2)))
  }
  
  @SerialVersionUID(0L)
  final case class StringToBoolEntry(
      key: scala.Option[String] = None,
      value: scala.Option[Boolean] = None
      ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[StringToBoolEntry] with com.trueaccord.lenses.Updatable[StringToBoolEntry] {
      @transient
      private[this] var __serializedSizeCachedValue: Int = 0
      private[this] def __computeSerializedValue(): Int = {
        var __size = 0
        if (key.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeStringSize(1, key.get) }
        if (value.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeBoolSize(2, value.get) }
        __size
      }
      final override def serializedSize: Int = {
        var read = __serializedSizeCachedValue
        if (read == 0) {
          read = __computeSerializedValue()
          __serializedSizeCachedValue = read
        }
        read
      }
      def writeTo(`_output__`: com.google.protobuf.CodedOutputStream): Unit = {
        key.foreach { __v =>
          _output__.writeString(1, __v)
        };
        value.foreach { __v =>
          _output__.writeBool(2, __v)
        };
      }
      def mergeFrom(`_input__`: com.google.protobuf.CodedInputStream): test.test.MyTest.StringToBoolEntry = {
        var __key = this.key
        var __value = this.value
        var _done__ = false
        while (!_done__) {
          val _tag__ = _input__.readTag()
          _tag__ match {
            case 0 => _done__ = true
            case 10 =>
              __key = Some(_input__.readString())
            case 16 =>
              __value = Some(_input__.readBool())
            case tag => _input__.skipField(tag)
          }
        }
        test.test.MyTest.StringToBoolEntry(
            key = __key,
            value = __value
        )
      }
      def getKey: String = key.getOrElse("")
      def clearKey: StringToBoolEntry = copy(key = None)
      def withKey(__v: String): StringToBoolEntry = copy(key = Some(__v))
      def getValue: Boolean = value.getOrElse(false)
      def clearValue: StringToBoolEntry = copy(value = None)
      def withValue(__v: Boolean): StringToBoolEntry = copy(value = Some(__v))
      def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
        __field.getNumber match {
          case 1 => key.getOrElse(null)
          case 2 => value.getOrElse(null)
        }
      }
      override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
      def companion = test.test.MyTest.StringToBoolEntry
  }
  
  object StringToBoolEntry extends com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.StringToBoolEntry] {
    implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[test.test.MyTest.StringToBoolEntry] = this
    def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): test.test.MyTest.StringToBoolEntry = {
      require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
      val __fields = descriptor.getFields
      test.test.MyTest.StringToBoolEntry(
        __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[String]],
        __fieldsMap.get(__fields.get(1)).asInstanceOf[scala.Option[Boolean]]
      )
    }
    def descriptor: com.google.protobuf.Descriptors.Descriptor = test.test.MyTest.descriptor.getNestedTypes.get(4)
    def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = throw new MatchError(__field)
    def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
    lazy val defaultInstance = test.test.MyTest.StringToBoolEntry(
    )
    implicit class StringToBoolEntryLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest.StringToBoolEntry]) extends com.trueaccord.lenses.ObjectLens[UpperPB, test.test.MyTest.StringToBoolEntry](_l) {
      def key: com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getKey)((c_, f_) => c_.copy(key = Some(f_)))
      def optionalKey: com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.key)((c_, f_) => c_.copy(key = f_))
      def value: com.trueaccord.lenses.Lens[UpperPB, Boolean] = field(_.getValue)((c_, f_) => c_.copy(value = Some(f_)))
      def optionalValue: com.trueaccord.lenses.Lens[UpperPB, scala.Option[Boolean]] = field(_.value)((c_, f_) => c_.copy(value = f_))
    }
    final val KEY_FIELD_NUMBER = 1
    final val VALUE_FIELD_NUMBER = 2
    implicit val keyValueMapper: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToBoolEntry, (String, Boolean)] =
      com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToBoolEntry, (String, Boolean)](__m => (__m.getKey, __m.getValue))(__p => test.test.MyTest.StringToBoolEntry(Some(__p._1), Some(__p._2)))
  }
  
  implicit class MyTestLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest]) extends com.trueaccord.lenses.ObjectLens[UpperPB, test.test.MyTest](_l) {
    def hello: com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getHello)((c_, f_) => c_.copy(hello = Some(f_)))
    def optionalHello: com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.hello)((c_, f_) => c_.copy(hello = f_))
    def foobar: com.trueaccord.lenses.Lens[UpperPB, Int] = field(_.getFoobar)((c_, f_) => c_.copy(foobar = Some(f_)))
    def optionalFoobar: com.trueaccord.lenses.Lens[UpperPB, scala.Option[Int]] = field(_.foobar)((c_, f_) => c_.copy(foobar = f_))
    def bazinga: com.trueaccord.lenses.Lens[UpperPB, Long] = field(_.getBazinga)((c_, f_) => c_.copy(bazinga = Some(f_)))
    def optionalBazinga: com.trueaccord.lenses.Lens[UpperPB, scala.Option[Long]] = field(_.bazinga)((c_, f_) => c_.copy(bazinga = f_))
    def primitiveSequence: com.trueaccord.lenses.Lens[UpperPB, scala.collection.Seq[String]] = field(_.primitiveSequence)((c_, f_) => c_.copy(primitiveSequence = f_))
    def repMessage: com.trueaccord.lenses.Lens[UpperPB, scala.collection.Seq[test.test.MyTest]] = field(_.repMessage)((c_, f_) => c_.copy(repMessage = f_))
    def optMessage: com.trueaccord.lenses.Lens[UpperPB, test.test.MyTest] = field(_.getOptMessage)((c_, f_) => c_.copy(optMessage = Some(f_)))
    def optionalOptMessage: com.trueaccord.lenses.Lens[UpperPB, scala.Option[test.test.MyTest]] = field(_.optMessage)((c_, f_) => c_.copy(optMessage = f_))
    def stringToInt32: com.trueaccord.lenses.Lens[UpperPB, scala.collection.immutable.Map[String, Int]] = field(_.stringToInt32)((c_, f_) => c_.copy(stringToInt32 = f_))
    def intToMytest: com.trueaccord.lenses.Lens[UpperPB, scala.collection.immutable.Map[Int, test.test.MyTest]] = field(_.intToMytest)((c_, f_) => c_.copy(intToMytest = f_))
    def repEnum: com.trueaccord.lenses.Lens[UpperPB, scala.collection.Seq[test.test.MyEnum]] = field(_.repEnum)((c_, f_) => c_.copy(repEnum = f_))
    def optEnum: com.trueaccord.lenses.Lens[UpperPB, test.test.MyEnum] = field(_.getOptEnum)((c_, f_) => c_.copy(optEnum = Some(f_)))
    def optionalOptEnum: com.trueaccord.lenses.Lens[UpperPB, scala.Option[test.test.MyEnum]] = field(_.optEnum)((c_, f_) => c_.copy(optEnum = f_))
    def intToEnum: com.trueaccord.lenses.Lens[UpperPB, scala.collection.immutable.Map[Int, test.test.MyEnum]] = field(_.intToEnum)((c_, f_) => c_.copy(intToEnum = f_))
    def boolToString: com.trueaccord.lenses.Lens[UpperPB, scala.collection.immutable.Map[Boolean, String]] = field(_.boolToString)((c_, f_) => c_.copy(boolToString = f_))
    def stringToBool: com.trueaccord.lenses.Lens[UpperPB, scala.collection.immutable.Map[String, Boolean]] = field(_.stringToBool)((c_, f_) => c_.copy(stringToBool = f_))
  }
  final val HELLO_FIELD_NUMBER = 1
  final val FOOBAR_FIELD_NUMBER = 2
  final val BAZINGA_FIELD_NUMBER = 3
  final val PRIMITIVE_SEQUENCE_FIELD_NUMBER = 4
  final val REP_MESSAGE_FIELD_NUMBER = 5
  final val OPT_MESSAGE_FIELD_NUMBER = 6
  final val STRING_TO_INT32_FIELD_NUMBER = 7
  final val INT_TO_MYTEST_FIELD_NUMBER = 8
  final val REP_ENUM_FIELD_NUMBER = 9
  final val OPT_ENUM_FIELD_NUMBER = 10
  final val INT_TO_ENUM_FIELD_NUMBER = 11
  final val BOOL_TO_STRING_FIELD_NUMBER = 12
  final val STRING_TO_BOOL_FIELD_NUMBER = 13
  @transient
  private val _typemapper_stringToInt32: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToInt32Entry, (String, Int)] = implicitly[com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToInt32Entry, (String, Int)]]
  @transient
  private val _typemapper_intToMytest: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToMytestEntry, (Int, test.test.MyTest)] = implicitly[com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToMytestEntry, (Int, test.test.MyTest)]]
  @transient
  private val _typemapper_intToEnum: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToEnumEntry, (Int, test.test.MyEnum)] = implicitly[com.trueaccord.scalapb.TypeMapper[test.test.MyTest.IntToEnumEntry, (Int, test.test.MyEnum)]]
  @transient
  private val _typemapper_boolToString: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.BoolToStringEntry, (Boolean, String)] = implicitly[com.trueaccord.scalapb.TypeMapper[test.test.MyTest.BoolToStringEntry, (Boolean, String)]]
  @transient
  private val _typemapper_stringToBool: com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToBoolEntry, (String, Boolean)] = implicitly[com.trueaccord.scalapb.TypeMapper[test.test.MyTest.StringToBoolEntry, (String, Boolean)]]
}
